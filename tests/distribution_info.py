from __future__ import annotations

from typing import Any, Callable, Generic, TypeVar

from jax.dtypes import canonicalize_dtype
from jax.tree_util import tree_map
from numpy.random import Generator
from tjax import ComplexArray, Shape

from efax import ExpectationParametrization, NaturalParametrization


def canonicalize_tree(tree: Any) -> Any:
    return tree_map(lambda array: array.astype(canonicalize_dtype(array.dtype)), tree)


NP = TypeVar('NP', bound=NaturalParametrization[Any, Any])
EP = TypeVar('EP', bound=ExpectationParametrization[Any])
Domain = TypeVar('Domain', bound=ComplexArray)


class DistributionInfo(Generic[NP, EP, Domain]):
    # New methods ----------------------------------------------------------------------------------
    def exp_to_scipy_distribution(self, p: EP) -> Any:
        """
        Args:
            p: Expectation parameters.
        Returns: A corresponding scipy distribution.
        """
        return self.nat_to_scipy_distribution(p.to_nat())

    def nat_to_scipy_distribution(self, q: NP) -> Any:
        """
        Args:
            p: Natural parameters.
        Returns: A corresponding scipy distribution.
        """
        return self.exp_to_scipy_distribution(q.to_exp())

    def exp_parameter_generator(self, rng: Generator, shape: Shape) -> EP:
        """
        Returns: Expectation parameters.  Defaults to converting values generated by
            nat_parameter_generator.
        """
        return self.nat_parameter_generator(rng, shape).to_exp()

    def nat_parameter_generator(self, rng: Generator, shape: Shape) -> NP:
        """
        Returns: Natural parameters.  Defaults to converting values generated by
            exp_parameter_generator.
        """
        return self.exp_parameter_generator(rng, shape).to_nat()

    def scipy_to_exp_family_observation(self, x: Domain) -> Domain:
        """
        Args:
            x: The observation that's produced by the scipy distribution.
        Returns: The observation that's expected by the exponential family.
        """
        return x

    # Magic methods --------------------------------------------------------------------------------
    def __init_subclass__(cls, **kwargs: Any) -> None:
        super().__init_subclass__(**kwargs)  # type: ignore

        if (cls.exp_to_scipy_distribution is DistributionInfo.exp_to_scipy_distribution
                and cls.nat_to_scipy_distribution is DistributionInfo.nat_to_scipy_distribution):
            raise TypeError

        if (cls.exp_parameter_generator is DistributionInfo.exp_parameter_generator
                and cls.nat_parameter_generator is DistributionInfo.nat_parameter_generator):
            raise TypeError

        for method in ['exp_parameter_generator', 'nat_parameter_generator',
                       'scipy_to_exp_family_observation']:
            old_method = getattr(cls, method)

            def new_method(*args: Any,
                           old_method: Callable[..., Any] = old_method,
                           **kwargs: Any) -> Any:
                return canonicalize_tree(old_method(*args, **kwargs))

            setattr(cls, method, new_method)
