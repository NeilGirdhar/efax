from __future__ import annotations

from collections.abc import Callable
from typing import Any, Generic, TypeVar

import pytest
from numpy.random import Generator, default_rng
from tjax import NumpyComplexArray, Shape

from efax import ExpectationParametrization, NaturalParametrization

NP = TypeVar('NP', bound=NaturalParametrization[Any, Any])
EP = TypeVar('EP', bound=ExpectationParametrization[Any])
Domain = TypeVar('Domain', bound=NumpyComplexArray)


class DistributionInfo(Generic[NP, EP, Domain]):
    # New methods ----------------------------------------------------------------------------------
    def exp_to_scipy_distribution(self, p: EP) -> Any:
        """Produce a corresponding scipy distribution from expectation parameters.

        Args:
            p: Expectation parameters.
        """
        return self.nat_to_scipy_distribution(p.to_nat())

    def nat_to_scipy_distribution(self, q: NP) -> Any:
        """Produce a corresponding scipy distribution from natural parameters.

        Args:
            q: Natural parameters.
        """
        return self.exp_to_scipy_distribution(q.to_exp())

    def exp_parameter_generator(self, rng: Generator, shape: Shape) -> EP:
        """Generate expectation parameters.

        Defaults to converting values generated by nat_parameter_generator.
        """
        return self.nat_parameter_generator(rng, shape).to_exp()

    def nat_parameter_generator(self, rng: Generator, shape: Shape) -> NP:
        """Generate natural parameters.

        Defaults to converting values generated by exp_parameter_generator.
        """
        return self.exp_parameter_generator(rng, shape).to_nat()

    def scipy_to_exp_family_observation(self, x: Domain) -> Domain:
        """The observation that's expected by the exponential family.

        Args:
            x: The observation that's produced by the scipy distribution.
        """
        return x

    def exp_class(self) -> type[EP]:
        return type(self.exp_parameter_generator(default_rng(), ()))

    def nat_class(self) -> type[NP]:
        return type(self.nat_parameter_generator(default_rng(), ()))

    @classmethod
    def name(cls) -> str:
        return cls.__name__.removesuffix('Info')

    @classmethod
    def tests_selected(cls, distribution_name: None | str) -> bool:
        return distribution_name is None or cls.name() == distribution_name

    @classmethod
    def skip_if_deselected(cls, distribution_name: None | str) -> None:
        if not cls.tests_selected(distribution_name):
            pytest.skip(f"Deselected {cls.name()}")

    # Magic methods --------------------------------------------------------------------------------
    def __init_subclass__(cls, **kwargs: Any) -> None:
        super().__init_subclass__(**kwargs)

        if (cls.exp_to_scipy_distribution is DistributionInfo.exp_to_scipy_distribution
                and cls.nat_to_scipy_distribution is DistributionInfo.nat_to_scipy_distribution):
            raise TypeError

        if (cls.exp_parameter_generator is DistributionInfo.exp_parameter_generator
                and cls.nat_parameter_generator is DistributionInfo.nat_parameter_generator):
            raise TypeError

        for method in ['exp_parameter_generator', 'nat_parameter_generator',
                       'scipy_to_exp_family_observation']:
            old_method = getattr(cls, method)

            def new_method(*args: Any,
                           old_method: Callable[..., Any] = old_method,
                           **kwargs: Any) -> Any:
                return old_method(*args, **kwargs)

            setattr(cls, method, new_method)
